<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>My first three.js app</title>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"
      integrity="sha512-dLxUelApnYxpLt6K2iomGngnHO83iUvZytA3YjDUCjT0HDOHKXnVYdf3hU4JjM8uEhxf9nD1/ey98U3t2vZ0qQ=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script>
      function gaussianRand() {
        //takes advantage of central limit therom to make approximate guassian random number
        var rand = 0;

        for (var i = 0; i < 6; i += 1) {
          rand += Math.random();
        }

        return rand / 6;
      }
      const X_ROTATION = 0.6;
      const Y_ROTATION = 3.14 / 4; //90 deg
      const MAX_FREEDOM = 0.05; //5 deg
      const MAX_SPEED = 0.0005; //radians per frame
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      scene.background = new THREE.Color("rgb(60, 200, 200)");

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const geometry = new THREE.BoxGeometry(10, 10, 10);
      const material = new THREE.MeshPhongMaterial({ color: 0x6c8693 });
      //   mat.onBeforeCompile = (shader) => {
      //       shader.uniforms.time = {value: 0}
      //       shader.vertexShader =
      //   }
      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);

      const light = new THREE.AmbientLight(0x404040, 2.05); // soft white light
      scene.add(light);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.target = cube;
      directionalLight.position.set(80, 100, 0);
      scene.add(directionalLight);

      camera.position.z = 15;
     

      cube.rotation.x += X_ROTATION;
      cube.rotation.y += Y_ROTATION;

      x_speed = gaussianRand() * MAX_SPEED;
      y_speed = gaussianRand() * MAX_SPEED;

      vectorSpeed = Math.sqrt(Math.pow(y_speed, 2) + Math.pow(x_speed, 2));

      function animate() {
        requestAnimationFrame(animate);

        if (
          Math.abs(cube.rotation.x - X_ROTATION) > MAX_FREEDOM ||
          Math.abs(cube.rotation.y - Y_ROTATION) > MAX_FREEDOM
        ) {
          x_speed > 0
            ? (x_speed = -gaussianRand() * MAX_SPEED)
            : (x_speed = gaussianRand() * MAX_SPEED);
          y_speed > 0
            ? (y_speed = -gaussianRand() * MAX_SPEED)
            : (y_speed = gaussianRand() * MAX_SPEED);
        }
        // if (Math.abs(cube.rotation.y - Y_ROTATION) > MAX_FREEDOM) {
        //   y_speed > 0
        //     ? (y_speed = -gaussianRand() * MAX_SPEED)
        //     : (y_speed = gaussianRand() * MAX_SPEED);
        // }

        cube.rotation.x += x_speed;
        cube.rotation.y += y_speed;
        // cube.rotation.x += 0.01;
        // cube.rotation.y += 0.01;
        renderer.render(scene, camera);
      }
      animate();
    </script>
  </body>
</html>
